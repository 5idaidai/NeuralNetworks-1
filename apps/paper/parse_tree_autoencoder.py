#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Created on March 7, 2014

@author: Chunwei Yan @ PKU
@mail:  yanchunwei@outlook.com

train recursive autoencoder based on parse trees generated by Standford Parser
'''
from __future__ import division
import sys
import numpy as np
sys.path.append('..')
sys.path.append('../../')
from paper import config as cg
from _word2vec import Trainer as Word2Vec
from models.recursive_autoencoder import RecursiveAutoencoder
from syntax_tree.parse_tree import SyntaxTreeParser
from exec_frame import BaseModel, ExecFrame

class ParseTreeAutoencoder(object):
    '''
    based on SyntaxTreeParser and BinaryTree
    '''
    def __init__(self, word2vec):
        '''
        :parameters:
            word2vec: pre-trained word2vec model
        '''
        self.word2vec = word2vec
        self.len_vector = cg.LEN_WORD_VECTOR
        self.rae = RecursiveAutoencoder(
            len_vec = self.len_vector,
            )

    def train_with_tree(self, stree):
        '''
        :parameters:
            parse_tree: string
        '''
        syntax_tree = SyntaxTreeParser(stree)
        if syntax_tree.root.n_children < 3:
            print '! skip', syntax_tree
            return 
        # init leaf node's vector
        syntax_tree.init_leaf_vec(self.word2vec, to_column=True)
        return self.rae.train_with_tree(syntax_tree)



class  _ParseTreeAutoencoder(BaseModel):
    def __init__(self, word2vec, strees):
        self.model = ParseTreeAutoencoder(word2vec)
        self.strees = strees

    def get_model(self):
        return self.model.rae

    def train_iter(self):
        costs = []
        for i,tree in enumerate(self.strees):
            #print i, tree
            try:
                cost = self.model.train_with_tree(tree)
            except Exception, e:
                print "error: ", e
                continue
            if cost is not None:
                costs.append(cost)
                print '%d>c\t%f' % (i, cost)
        return np.mean(costs)





class Main(ExecFrame):

    def __init__(self, w2v_ph, model_root, 
            strees = [],
            n_iters=1000, n_step2save=250,
            window=5, tolerance=0.03):
        _word2vec = Word2Vec()
        _word2vec.model_fromfile(w2v_ph)

        model = _ParseTreeAutoencoder( word2vec = _word2vec,
                strees = strees,
            )
        ExecFrame.__init__(self,
            model = model,
            model_root = model_root,
            n_iters = n_iters,
            n_step2save = n_step2save,
            window = window,
            tolerance = tolerance
            )
        self.c_rate = 0.0
        self.cur_c_rate = 0.0


def get_stree_from_paths(paths):
    strees = []
    for ph in paths:
        with open(ph) as f:
            while True:
                line = f.readline()
                if not line:break
                strees.append(line)
    return strees



if __name__ == "__main__":
    args = sys.argv[1:]
    if len(args) < 1:
        print "cat paths | ./cmd.py model_root w2v_ph"
        sys.exit(-1)

    paths = sys.stdin.read().split()

    model_root, w2v_ph = args

    strees = get_stree_from_paths(paths)
    print 'load strees', len(strees)

    _word2vec = Word2Vec()
    _word2vec.model_fromfile(w2v_ph)

    '''
    main = Main(
        w2v_ph = w2v_ph,
        model_root = model_root,
        )
    main.run(main)
    '''

    pae = _ParseTreeAutoencoder(
        word2vec = _word2vec,
        strees = strees,
        )
    cost = pae.train_iter()
    name = "%f.pk" % cost
    pae.save_model(model_root, name)
