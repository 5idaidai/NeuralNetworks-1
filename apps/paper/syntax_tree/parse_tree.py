#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Created on March 6, 2014

@author: Chunwei Yan @ PKU
@mail:  yanchunwei@outlook.com

parse the syntax tree
'''
from __future__ import division
import re
import numpy as np
import sys
sys.path.append('../../..')
from models.recursive_autoencoder.tree import BinaryNode


class Node(BinaryNode):

    is_token = lambda x:x.startswith('(')
    is_content = lambda x:x.endswith(')')

    def __init__(self, name, lchild=None, rchild=None):
        BinaryNode.__init__(self, lchild, rchild)
        self.name = self._space_token(name)
        self.lchild = lchild
        self.rchild = rchild
        # run
        self.expand_subtree()
        self.vector = None

    def is_leaf(self):
        return self.lchild == None and self.rchild  == None

    def get_word(self):
        if self.is_leaf():
            rp = re.compile(r"(?P<name>([a-zA-Z0-9.,?!':;$\-`*/\\~+=#_]+)\))")
            res = rp.findall(self.name)
            assert res, "no leaf's word find '%s'" % self.name
            word = res[0][-1].lower()
            if word == '\\':
                word = '\\\\'
            return word


    def __repr__(self):
        return "<Node: %s>" % self.name

    def expand_subtree(self):
        child_names = self.get_subtree_children_names()
        self.create_child_nodes(child_names)

    def get_subtree_children_names(self):
        '''
        get children's names of the next level
        '''
        stack = []
        # save current child node's name parts
        content = []
        child_names = []
        n_tokens = 0
        n_content = 0
        #self._pre_rm_redundant_token()
        is_token = lambda x:x.startswith('(')
        is_content = lambda x:x.endswith(')')

        for i,part in enumerate(self.name.split()):
            if is_token(part):
                stack.append(part)
                n_tokens += 1

            elif is_content(part):
                stack.append(part)
                n_content += 1
                #content.insert(0, stack.pop())
                #content.insert(0, stack.pop())
                if n_content + 1 == n_tokens:
                    content = ' '.join(stack[1:])
                    child_names.append(content)
                    stack = [ stack[0] ]
        return child_names

    def create_child_nodes(self, names):
        if len(names) == 2:
            self.lchild = Node(names[0])
            self.rchild = Node(names[1])

        elif len(names) > 2:
            self.lchild = Node(names[0])
            new_rchild_name = "(NEW %s )" % ' '.join(names[1:])
            self.rchild = Node(new_rchild_name)
        elif len(names) == 1:
            self.lchild = Node(names[0])

        elif len(names) == 0:
            pass


    def _space_token(self, line):
        '''
        add a space between ))
        '''
        while line.find('))') != -1:
            line = line.replace('))', ') )')
            line = line.replace('\n', '')
        return line





class SyntaxTreeParser(object):

    Node = Node
    
    def __init__(self, line=None):
        self.line = line
        if self.line:
            self.build_tree()

    def set_sentence(self, line):
        self.line = line
        self.build_tree()

    def get_root(self):
        return self.root if self.root.lchild and self.root.rchild else self.root.lchild

    def build_tree(self):
        '''
        (S (NP (PRP I)) (VP (VBD saw) (NP (DT a) (NN man)) (PP (IN with) (NP (DT a) (NN telescope)))))

        :parameters:
            line: string
                a line of syntax tree generated by 
                    Standford Parser
        '''
        self.root = self.Node(self.line)

        self._adjust_tree(self.root)

    def _adjust_tree(self, node):
        '''
        remove redundant hidden nodes
        '''
        if not node:
            return

        for i in range(3):
            c = node.lchild
            if c and not node.rchild:
                node.lchild = c.lchild
                node.rchild = c.rchild


        self._adjust_tree(node.lchild)
        self._adjust_tree(node.rchild)


    def get_ori_sentence(self):
        words = []
        def visit(node):
            if node:
                if node.is_leaf():
                    word = node.get_word()
                    words.append(word)
                else:
                    visit(node.lchild)
                    visit(node.rchild)
        visit(self.root)
        return words

    def init_leaf_vec(self, word2vec, to_column=False):
        '''
        init leaf's vectors
        '''
        def init_vec(node):
            if not node: return
            if node.is_leaf():
                word = node.get_word()
                vector = word2vec.get_word_vec(word)
                node.vector = vector
                if to_column:
                    len_vec = len(vector)
                    node.vector = np.array(word2vec.get_word_vec(word)).reshape((len_vec, 1))
            else:
                init_vec(node.lchild)
                init_vec(node.rchild)

        init_vec(self.root)
    

    def draw_graph(self, fname="tmp.dot", detail=False):
        '''
        draw the graph using graphviz
        '''
        node_idx = [0]
        dot = ["digraph G {"]

        def scan_tree(fname, node, node_idx, dot):
            if node != None:
                node_idx[0] += 1
                name = "node_%d" % node_idx[0]
                if detail:
                    dot += [
                        '%s [label="%s", shape="box"];' % (name, node.name),
                    ]

                else:
                    if node.is_leaf():
                        dot += [
                            '%s [label="%s", shape="box"];' % (name, node.get_word()),]
                    else:
                        dot.append('%s [label="%s"];' % (name, 'inner node'))
                dot.append( '%s -> %s;' % (fname, name))
                scan_tree(name, node.lchild, node_idx, dot)
                scan_tree(name, node.rchild, node_idx, dot)

        scan_tree('node_0', self.root, node_idx, dot)
        dot.append("}")
        dot_file = '\n'.join(dot)
        #print 'dot', dot_file
        #print 'write dot file to ', fname
        with open(fname, 'w') as f:
            f.write(dot_file)





if __name__ == "__main__":
    #node = Node("(NP a)")

    #print 'child names:', node.get_subtree_children_names()
    #line = "(S (NP (PRP It)) (VP (VBZ uses) (NP (NP (DT a) (NN satellite)) (PP (IN in) (NP (NP (DT a) (JJ fixed) (NN location)) (VP (VBN known) (PP (IN as) (NP (NP (NNP L1)) (SBAR (WHNP (WDT that)) (S (VP (MD will) (VP (VB allow) (S (NP (PRP it)) (VP (TO to) (VP (VB have) (NP (NP (DT a) (JJ continuous) (NN view)) (PP (IN of) (NP (NNP Earth)))) (PP (IN in) (NP (NN sunlight))))))))))))))))))"
    #line = "(S (VP (VB SAINT-JEAN-SUR-RICHELIEU) (, ,) (S (S (NP (NNP Quebec) (PRP It)) (VP (VBZ is) (NP (NP (DT a) (NN paradox)) (SBAR (WHNP (WDT that)) (S (VP (VBZ keeps) (NP (NP (DT all)) (PP (IN of) (NP (NNP Canada)))) (PP (IN in) (NP (NN limbo))))))))) (: :) (S (NP (JJS Most) (NNPS Quebeckers)) (VP (VBP are) (RB n't) (ADJP (JJ eager) (PP (IN for) (NP (NP (DT another) (NN referendum)) (PP (IN on) (NP (NN secession)))))))) (, ,) (RB yet) (S (NP (PRP they)) (VP (VBP seem) (PP (IN on) (NP (NP (DT the) (NN verge)) (PP (IN of) (S (VP (VBG re-electing) (NP (NP (DT a) (NN government)) (VP (VBN committed) (PP (TO to) (NP (NN independence)))))))))))))))"
    #line = "(FRAG (X (SYM *)) (NP (NNP MOTION) (NNP PICTURES)))"
    #line = "(S (NP (PRP It)) (VP (VBZ is) (ADVP (RB clearly)) (PP (IN in) (NP (DT the) (JJ national) (NN interest) (S (VP (TO to) (VP (VB prevent) (NP (NP (DT the) (JJ further) (NN spread)) (PP (IN of) (NP (NNP HIV) (NNP \) (NNP AIDS)))) (PP (IN in) (NP (NNP Africa))) (, ,) (SBAR (S (NP (PRP she)) (VP (VBD said)))))))))))"
    line = "(S (NP (PRP I)) (VP (VBD was) (VP (VP (VBG watching) (NP (PDT all) (DT the) (NNS others))) (CC and) (VP (VBG thinking) (PRT (RP back)) (SBAR (WHADVP (WRB when)) (S (NP (PRP I)) (VP (VBD saw) (NP (PRP$ their) (NNS performances)))))) (CC and) (VP (VBG thinking) (PP (IN of) (SBAR (SBAR (WHADVP (WRB how)) (S (NP (NP (DT the) (NN academy)) (VP (VBN changed) (`` `) (NP (NP (DT The) (NN winner)) (SBAR (S (VP (VBZ is))))) ('' ') (PP (TO to) (`` `) (NP (DT The) (NNP Oscar))))) (VP (VBZ goes) (PP (TO to)) (, ,) ('' ')))) (CC and) (SBAR (IN if) (S (SBAR (RB ever) (S (NP (EX there)) (VP (VBD was) (NP (NP (DT a) (NN category)) (SBAR (WHADVP (WRB where)) (S (NP (DT the) (NNP Oscar)) (VP (VBZ goes) (PP (TO to) (NP (NN someone))) (PP (IN without) (S (NP (PRP$ their)) (VP (VBG being) (NP (DT a) (NN winner)))))))))))) (, ,) (NP (PRP it)) (VP (VBZ 's) (NP (DT this) (NN one))))) (SBAR (IN because) (S (NP (PRP I)) (VP (VBP do) (RB not) (VP (VB feel) (PP (IN like) (S (VP (VBG being) (NP (DT the) (NN winner)))))))))))))))"
    #line = "(S (VP (MD will) (VP (VB allow) (S (NP (PRP it) ) (VP (TO to) (VP (VB have) (NP (NP (DT a) (JJ continuous) (NN view) ) (PP (IN of) (NP (NNP Earth) ) ) ) (PP (IN in) (NP (NN sunlight) ) ) ) ) ) ) ) )"
    #line ="(S (MD will) (VB allow) (S (PRP it) (VP (TO to) (VP (VB have) (NP (NP (DT a) (JJ continuous) (NN view) ) (PP (IN of) (NP (NNP Earth) ) ) ) (PP (IN in) (NN sunlight) ) ) ) ) )"

    tree = SyntaxTreeParser(line)
    #node = Node(line)
    tree.draw_graph(detail=False)
    import sys
    sys.path.append('..')
    #from _word2vec import sentence_from_tree
    #print sentence_from_tree(tree)
