#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Created on March 6, 2014

@author: Chunwei Yan @ PKU
@mail:  yanchunwei@outlook.com

parse the syntax tree
'''
from __future__ import division
import re
import sys
sys.path.append('../../..')
from models.recursive_autoencoder.tree import BinaryNode


class Node(BinaryNode):

    is_token = lambda x:x.startswith('(')
    is_content = lambda x:x.endswith(')')

    def __init__(self, name, lchild=None, rchild=None):
        BinaryNode.__init__(self, lchild, rchild)
        self.name = self._space_token(name)
        self.lchild = lchild
        self.rchild = rchild
        # run
        self.expand_subtree()
        self.vector = None

    def is_leaf(self):
        return self.lchild == None and self.rchild  == None

    def get_word(self):
        if self.is_leaf():
            #print 'name:', self.name
            rp = re.compile(r"(?P<name>([a-zA-Z0-9.,?!':;$\-`]+)\))")
            res = rp.findall(self.name)
            assert res, "no leaf's word find"
            return res[0][-1].lower()

    def __repr__(self):
        return "<Node: %s>" % self.name

    def expand_subtree(self):
        child_names = self.get_subtree_children_names()
        self.create_child_nodes(child_names)

    def get_subtree_children_names(self):
        '''
        get children's names of the next level
        '''
        stack = []
        # save current child node's name parts
        content = []
        child_names = []
        n_tokens = 0
        n_content = 0
        #self._pre_rm_redundant_token()
        is_token = lambda x:x.startswith('(')
        is_content = lambda x:x.endswith(')')

        for i,part in enumerate(self.name.split()):
            if is_token(part):
                #if n_continuous_tokens < 3:
                #print 'token:', part
                stack.append(part)
                n_tokens += 1

            elif is_content(part):
                #print 'content:', part
                stack.append(part)
                n_content += 1
                #content.insert(0, stack.pop())
                #content.insert(0, stack.pop())
                if n_content + 1 == n_tokens:
                    content = ' '.join(stack[1:])
                    child_names.append(content)
                    stack = [ stack[0] ]
        #print 'child_names', child_names
        return child_names

    def create_child_nodes(self, names):
        if len(names) == 2:
            self.lchild = Node(names[0])
            self.rchild = Node(names[1])

        elif len(names) > 2:
            self.lchild = Node(names[0])
            new_rchild_name = "(NEW %s )" % ' '.join(names[1:])
            self.rchild = Node(new_rchild_name)
        elif len(names) == 1:
            #print "children's name = 1", names
            self.lchild = Node(names[0])

        elif len(names) == 0:
            pass
            #print "children's name = 0" 


    def _space_token(self, line):
        '''
        add a space between ))
        '''
        while line.find('))') != -1:
            line = line.replace('))', ') )')
            line = line.replace('\n', '')
        return line





class SyntaxTreeParser(object):

    Node = Node
    
    def __init__(self, line=None):
        self.line = line
        if self.line:
            self.build_tree()

    def set_sentence(self, line):
        self.line = line
        self.build_tree()

    def build_tree(self):
        '''
        (S (NP (PRP I)) (VP (VBD saw) (NP (DT a) (NN man)) (PP (IN with) (NP (DT a) (NN telescope)))))

        :parameters:
            line: string
                a line of syntax tree generated by 
                    Standford Parser
        '''
        self.root = self.Node(self.line)
        self._adjust_tree(self.root)

    def _adjust_tree(self, node):
        '''
        remove redundant hidden nodes
        '''
        if not node:
            return
        c = node.lchild
        if c and c.lchild and not c.rchild:
            node.lchild = c.lchild
        c = node.rchild
        if c and c.lchild and not c.rchild:
            node.rchild = c.lchild
        self._adjust_tree(node.lchild)
        self._adjust_tree(node.rchild)


    def get_ori_sentence(self):
        words = []
        def visit(node):
            if node:
                if node.is_leaf():
                    word = node.get_word()
                    words.append(word)
                else:
                    visit(node.lchild)
                    visit(node.rchild)
        visit(self.root)
        return words

    def init_leaf_vec(self, word2vec):
        '''
        init leaf's vectors
        '''
        def init_vec(node):
            if not node: return
            if node.is_leaf():
                word = node.get_word()
                node.vector = word2vec.get_word_vec(word)
            else:
                init_vec(node.lchild)
                init_vec(node.rchild)

        init_vec(self.root)
    

    def draw_graph(self, fname="tmp.dot", detail=False):
        '''
        draw the graph using graphviz
        '''
        node_idx = [0]
        dot = ["digraph G {"]

        def scan_tree(fname, node, node_idx, dot):
            if node != None:
                node_idx[0] += 1
                name = "node_%d" % node_idx[0]
                if detail:
                    dot += [
                        '%s [label="%s", shape="box"];' % (name, node.name),
                    ]

                else:
                    if node.is_leaf():
                        dot += [
                            '%s [label="%s", shape="box"];' % (name, node.get_word()),]
                    else:
                        dot.append('%s [label="%s"];' % (name, 'inner node'))
                dot.append( '%s -> %s;' % (fname, name))
                scan_tree(name, node.lchild, node_idx, dot)
                scan_tree(name, node.rchild, node_idx, dot)

        scan_tree('node_0', self.root, node_idx, dot)
        dot.append("}")
        dot_file = '\n'.join(dot)
        #print 'dot', dot_file
        #print 'write dot file to ', fname
        with open(fname, 'w') as f:
            f.write(dot_file)





if __name__ == "__main__":
    #node = Node("(NP a)")

    #print 'child names:', node.get_subtree_children_names()
    line = "(S (NP (PRP It)) (VP (VBZ uses) (NP (NP (DT a) (NN satellite)) (PP (IN in) (NP (NP (DT a) (JJ fixed) (NN location)) (VP (VBN known) (PP (IN as) (NP (NP (NNP L1)) (SBAR (WHNP (WDT that)) (S (VP (MD will) (VP (VB allow) (S (NP (PRP it)) (VP (TO to) (VP (VB have) (NP (NP (DT a) (JJ continuous) (NN view)) (PP (IN of) (NP (NNP Earth)))) (PP (IN in) (NP (NN sunlight))))))))))))))))))"
    #line = "(S (VP (MD will) (VP (VB allow) (S (NP (PRP it) ) (VP (TO to) (VP (VB have) (NP (NP (DT a) (JJ continuous) (NN view) ) (PP (IN of) (NP (NNP Earth) ) ) ) (PP (IN in) (NP (NN sunlight) ) ) ) ) ) ) ) )"
    #line ="(S (MD will) (VB allow) (S (PRP it) (VP (TO to) (VP (VB have) (NP (NP (DT a) (JJ continuous) (NN view) ) (PP (IN of) (NP (NNP Earth) ) ) ) (PP (IN in) (NN sunlight) ) ) ) ) )"

    tree = SyntaxTreeParser(line)
    #node = Node(line)
    tree.draw_graph(detail=False)
    import sys
    sys.path.append('..')
    #from _word2vec import sentence_from_tree
    #print sentence_from_tree(tree)
    

